/************************************************************
 * ΠΛΗ10 
 * Εισαγωγή στη γλώσσα προγραμματισμού C.
 * 
 * 3o Αρχείο: 03_pointer_example.c
 *
 * Αυτό είναι το τρίτο πρόγραμμα προς επίδειξη. Ζητούμενο να 
 * κατανοηθούν βασικά θέματα δεικτών. 
 * Στο πρόγραμμα δείχνουμε αναλυτικά: 
 * - Δήλωση δεικτών
 * - Δήλωση (προ-δήλωση) συναρτήσεων
 * - void και επιστροφή συνάρτησης
 * - Τελεστής διεύθυνσης μεταβλητής: &
 * - Αποθήκευση μεταβλητών στη μνήμη
 * - Κλήση συνάρτησης
 * - Πέρασμα με τιμή - πέρασμα με αναφορά
 *
 ************************************************************/
 
#include <stdio.h>

/* Ο compiler της C επεξεργάζεται το πρόγραμμα από την αρχή προς το τέλος.
 * Κάθε φορά που συναντά κλήση προς μια συνάρτηση, αναζητά την υλοποίηση της συνάρτησης αυτής. 
 * Για να είναι τα προγράμματά μας ευκρινέστερα, επιτρέπεται να υλοποιήσουμε τις 
 * συναρτήσεις μας όπου θέλουμε, αρκεί να δώσουμε στην αρχή του αρχείου τις δηλώσεις τους. 
 * Οι δύο παρακάτω δηλώσεις σημαίνουν ότι οι συναρτήσεις exchange() και point_exchange() είναι
 * του τύπου που περιγράφεται και ότι οι υλοποιήσεις τους ακολουθούν κάπου στο αρχείο αυτό.
 */
void exchange(int i, int j);
void point_exchange(int *i, int *j);

int a;

/* Με την παρακάτω δήλωση δηλώνουμε έναν δείκτη στη C. Η δήλωση αυτή σημαίνει: 
 * " Η μεταβλητή p είναι τύπου δείκτη και στη διεύθυνση που αποθηκεύεται σε αυτή
 *   θεωρούμε ότι βρίσκεται μεταβλητή τύπου int" 
 */

int * p;

main()
{
	char h;
	int c;
	int d;

	/* Ο τελεστής & μας δίνει τη διεύθυνση που αποθηκεύεται μια μεταβλητή. Η διεύθυνση αυτή 
	 * αντιστοιχεί σε πραγματική ή εικονική μνήμη, ανάλογα το μοντέλο λειτουργίας 
	 * του επεξεργαστή!
	 * Ας δούμε σε ποια διεύθυνση αποθηκεύονται οι μεταβλητές μας:
	 */
	printf("a is stored at memory position %d\n", &a);
	h = getchar();
	printf("d is stored at memory position %d\n", &d);
	h = getchar();
	printf("c is stored at memory position %d\n\n", &c);
	/* Είναι τυχαίο που οι μεταβλητές c και d είναι αποθηκευμένες σε τόσο κοντινές θέσεις 
	 * μνήμης? Καθόλου! Η απόσταση των διευθύνσεων είναι 4 (4 bytes), όσο δηλαδή και 
	 * ο χώρος που καταλαμβάνει ένας int. ʼρα, οι δύο μεταβλητές είναι ουσιαστικά όσο 
	 * πιο κοντά γίνεται! 
	 * Όμως γιατί η a δεν είναι κοντά τους? O λόγος είναι ότι η a είναι δηλωμένη έξω 
	 * από την main() με αποτέλεσμα ο compiler να της δίνει μνήμη πριν καν ξεκινήσει το 
	 * πρόγραμμα να εκτελείται. Όμως και εκεί τοποθετεί τις μεταβλητές με τη σειρά! 
	 * Ας δούμε αν η p αποθηκεύεται δίπλα στην a.....
	 */
	h = getchar();
	printf("p is stored at memory position %d and \n\
	points to memory position %d,",&p,p);
	//printf(" the value there is %d\n",*p);

	/* Σωστά! Όμως γιατί η παραπάνω γραμμή είναι σχολιασμένη ( οι δύο χαρακτήρες //
	 * στη C σημαίνουν ότι ότι ακολουθεί μέχρι το τέλος της σειράς είναι σχόλιο και
	 * δεν λαμβάνεται υπόψη στον κώδικα)? Η απάντηση είναι απλή:
	 * Ο τελεστής * μας δίνει το περιεχόμενο της θέσης μνήμης όπου δείχνει μία 
	 * μεταβλητή τύπου δείκτη. Στην παραπάνω σχολιασμένη γραμμή ζητάμε από το πρόγραμμα 
	 * να εκτυπώσει τα περιεχόμενα της θέσης μνήμης που δείχνει ο p. Όμως ο p δεν 
	 * έχει αρχικοποιηθεί με αποτέλεσμα να περιέχει τη διεύθυνση 0. Και στη διεύθυνση
	 * αυτή δεν έχει πρόσβαση κανένα πρόγραμμα παρά μόνο το λειτουργικό σύστημα που 
	 * τρέχει στον υπολογιστή. Είναι λοιπόν λάθος! Για να δούμε όμως, τι θα συμβεί αν 
	 * τρέξουμε αυτόν τον κώδικα? Σταματείστε την εκτέλεση του προγράμματος, 
	 * βγάλτε τα σχόλια από την παραπάνω γραμμή, αποθηκεύστε, κάνετε compile και τρέξτε 
	 * τον κώδικα ξανά! 
	 * Είδατε ότι το σύστημα σταματά την εκτέλεση του προγράμματος καθώς αυτό οδηγήθηκε
	 * σε παραβίαση των ορίων του. Επαναφέρετε τώρα τα σχόλια ώστε να συνεχίσουμε.....
	 */


	h = getchar();

	/* Μια καλή ιδέα για την αρχικοποίηση ενός δείκτη είναι να τον βάλουμε να 
	 * δείχνει σε μία άλλη μεταβλητή! Για το παράδειγμα αυτό, αναθέτουμε στον 
	 * p την διεύθυνση της a....
	 */
	p = &a;

	printf("p is stored at memory position %d and \n\
	points to memory position %d,",&p,p);

	/* ...και όντως βλέπετε ότι ο p περιέχει την σωστή διεύθυνση....
	 */
	printf(" the value there is %d\n",*p);

	/* ... αλλά και μπορεί να δεί την τιμή που έχει η a....
	 */
	h = getchar();

	/* Ας το επιβεβαιώσουμε..... */

	printf("the value of a = %d\n",a);
    
	h = getchar();

	/* Όντως! Όμως με τον τρόπο αυτό μπορούμε να κάνουμε κάτι πολύ σημαντικό! 
	 * Μπορούμε να αλλάξουμε την τιμή της a χωρίς καν να αναφερθούμε στη μεταβλητή. 
	 * Η παρακάτω εντολή μεταφράζεται: " κάνε το περιεχόμενο της θέσης μνήμης 
	 * στην οποία δείχνει ο δείκτης p να είναι 234".
	 * Για να δούμε...
	 */
	*p = 234;

	printf("the value of a = %d\n",a);

	/* Αυτό σημαίνει ότι μπορούμε στη C να αλλάζουμε τιμή στις μεταβλητές 
	 * χωρίς να αναφερόμαστε άμεσα στις μεταβλητές αλλά έμμεσα! 
	 * Το "τρικ" αυτό το χρησιμοποιούμε για να μια πολύ σημαντική λειτουργία που δεν 
	 * υλοποιείται με άλλο τρόπο στη C. Το πέρασμα με αναφορά!
	 * Στη C όλες οι συναρτήσεις περνούν τα ορίσματά τους με τιμή. Αυτό σημαίνει ότι 
	 * οι τιμές των μεταβλητών - παραμέτρων της συνάρτησης μετά το τέλος της 
	 * εκτέλεσης της συνάρτησης δεν μεταβάλλονται, ανεξάρτητα από την τιμή που 
	 * τους έχει καταχωρηθεί στη συνάρτηση! Χαρακτηριστικό παράδειγμα αποτελεί η
	 * συνάρτηση exchane(int a, int c) η οποία παίρνει σαν παραμέτρους δύο int 
	 * και στη συνέχεια τους ανταλλάσσει την τιμή. Για να είμαστε σίγουροι ότι 
	 * η ανταλλαγή έγινε σωστά, εκτυπώνουμε τους ακεραίους μέσα στη συνάρτηση!
	 */
	h = getchar();

	c = 30;

	printf("Start:     a : %d, c : %d\n",a,c);

	h = getchar();

	exchange(a,c);

	h = getchar();

	printf("main:      a : %d, c : %d\n",a,c);

	/* Όμως βλέπουμε ότι μετά το τέλος της εκτέλεσης της exchange οι a και c
	 * δεν άλλαξαν τιμή! Πώς όμως μπορούμε να αλλάξουμε τιμή στις μεταβλητές? 
	 * Η απάντηση είναι απλή! Θα χρησιμοποιήσουμε τις διευθύνσεις των 
	 * μεταβλητών και όχι τις ίδιες τις μεταβλητές! Το σκεπτικό είναι το εξής: 
	 * Αντί για την τιμή των a και c θα περάσουμε σαν παράμετρο στη συνάρτηση τις
	 * διευθύνσεις των a και c! Η συνάρτηση δεν θα αλλάζει την παράμετρο που παίρνει 
	 * στην είσοδο αλλά την τιμή που βρίσκεται στη συγκεκριμένη διεύθυνση. Η διεύθυνση 
	 * παραμένει σε κάθε περίπτωση ίδια! 
	 * Φυσικά πρέπει να τροποποιηθεί αντίστοιχα και η exchange. Η συνάρτηση point_exchange()
	 * υλοποιεί τη συγκεκριμένη μετατροπή. Παρατηρήστε ότι οι παράμετροι εισόδου της 
	 * συνάρτησης είναι δείκτες ενώ η ανταλλαγή γίνεται σε περιεχόμενα δεικτών.
	 */
	h = getchar();

	point_exchange(&a,&c);

	h = getchar();

	printf("main:      a : %d, c : %d\n",a,c);

	/* Τώρα οι αλλαγές επηρεάζουν και την τιμή των μεταβλητών στο ίδιο το πρόγραμμα! 
	 * Μπορείτε τωρα να βρείτε γιατί βάζουμε το & μπροστά από τις μεταβλητές της scanf()?
	 */
	h = getchar();
}

/* H συνάρτηση exchange δέχεται σαν είσοδο δύο int και δεν επιστρέφει καμία τιμή
 * (για το λόγο αυτό είναι τύπου void).
 */
void exchange(int i, int j)
{
	int temp;

	temp = i;
	i=j;
	j=temp;

	printf("exchange:  i : %d, j : %d\n",i,j);
}

/* H συνάρτηση point_exchange δέχεται σαν είσοδο δύο δείκτες σε int και δεν επιστρέφει 
 * καμία τιμή.
 */

void point_exchange(int *i, int *j)
{
	int temp;

	temp = *i;
	*i=*j;
	*j=temp;

	printf("p_exchange i : %d, j : %d\n",*i,*j);
}



