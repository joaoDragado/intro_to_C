/*****************************************************************************
 * ΠΛΗ10 
 * Εισαγωγή στη γλώσσα προγραμματισμού C.
 * 
 * 30o Αρχείο: 30_merge.c
 *
 * Αυτό είναι το τριακοστό πρόγραμμα προς επίδειξη.
 * Πρόβλημα: Ζητείται να αναπτυχτεί ένα πρόγραμμα σε C το οποίο να δέχεται
 * από το χρήστη δύο ακολουθίες από ακέραιους αριθμούς. Η κάθε ακολουθία
 * πρέπει να έχει το πολύ 10  ακέραιους και να είναι ταξινομημένη σε γνησίως
 * αύξουσα διάταξη. Επίσης να ελέγχει αν τα δεδομένα είναι όπως παραπάνω
 * (δηλαδή αν τα μήκη των ακολουθιών είναι μικρότερα ή ίσα του 10 και εάν οι
 * ακολουθίες είναι ταξινομημένες σε γνήσια αύξουσα διάταξη). Τέλος,
 * να συγχωνεύει τις δύο παραπάνω ακολουθίες σε μία, ταξινομημένη σε
 * αύξουσα διάταξη και την εκτυπώνει.
 * Λύση:  Για την επίλυση του προβλήματος αποθηκεύουμε κάθε μια από τις δυο
 * ακολουθίες που δίνει ο χρήστης σε μια γραμμή ενός δισδιάστατου πίνακα.
 * Εάν σε κάποια από τις δυο ακολουθίες βρεθεί λάθος (μηδενική ακολουθία,
 * όχι ταξινομημένη σε γνήσια αύξουσα διάταξη, ή με πλήθος μεγαλύτερο των 10
 * στοιχείων) τότε το πρόγραμμα σταματά. Εάν τα δεδομένα είναι σωστά τότε
 * εργαζόμαστε ως εξής: Χρησιμοποιούμε δυο δείκτες i και j που αρχικά δείχνουν 
 * στη θέση 0 της πρώτης και δεύτερης ακολουθίας αντίστοιχα. Στη συνέχεια
 * συγκρίνουμε τον αριθμό στη θέση i της πρώτης ακολουθίας με τον αριθμό στη
 * θέση j της δεύτερης ακολουθίας και βάζουμε τον μικρότερο από τους δυο στη
 * θέση k της νέας ακολουθίας. Αυξάνουμε τον δείκτη k και τον δείκτη της θέση
 * που επιλέξαμε πριν, και επαναλαμβάνουμε το προηγούμενο βήμα έως ότου κάποιος
 * από τους δείκτες i, j ξεπεράσει το τέλος της αντίστοιχης ακολουθίας.
 * Σε αυτό το σημείο ενδέχεται να υπάρχει ένα μέρος από το πολύ μια από τις δυο
 * ακολουθίες που δεν έχουμε ακόμη εισάγει στη νέα ακολουθία.
 * Απλά αντιγράφουμε αυτό το μέρος στο τέλος της νέας ακολουθίας
 * Έννοιες που συναντάμε: δείκτης, συνθήκη ελέγχου, βρόγχος επανάληψης, θέση μνήμης
 ****************************************************************************/
 
#include <stdio.h>
#include <stdlib.h>
#define MAX 10

main()
{
    int n1,n2,m,p,x;
    int error;
    int i,j,k,a[2][MAX],b[2*MAX];
    m=0;
    /* εισαγωγή αριθμών από το χρήστη μέχρι να δωθεί -1 */
    do
    {
        i=0; /* μετρά ένα-ένα τα στοιχεία που δίνει ο χρήστης σε κάθε ακολουθία */
        error=0; /* όταν γίνει 1 σημαίνει ότι έχει βρεθεί λάθος στα δεδομένα */
        printf("Dwse moy <= 10 arithmous (-1 gia telos) gia thn akolouth. #%d\n",m+1);
        do
        {
            scanf("%d",&x);
            if (i == 0)
            /* Η error γίνεται 1 αν το πρώτο στοιχείο κάποιας από τις
            ακολουθίες είναι -1 */
            error=(x==-1);
            else
            /* Η error γίνεται 1 αν η σύγκριση με το προηγούμενο στοιχείο
            που δώθηκε αποδεικνύει ότι η ακολουθία δεν είναι γνησίως αύξουσα
            ή αν το πλήθος των στοιχείων είναι μεγαλύτερο από MAX */
            if (x!=-1)
            error=((a[m][i-1] >= x) || (i >= MAX));
            if ((x!=-1) && (!error))
            {
                a[m][i]=x;
                i=i+1;
            }
        } while ((x!= -1) && (!error));
        if (!error)
        {
            /* κρατάμε το μήκος της αντίστοιχης  ακολουθίας*/
            switch (m)
            {
                case 0: n1=i; break;
                case 1: n2=i; break;
            }
            m=m+1; /* περνάμε στην επόμενη ακολουθία */
        }
    }while ((m<2) && (!error));
    if (error)
    printf("Lathos dedomena\n");
    else
    {
        i=0; /* δείχνει σε θέσεις της πρώτης ακολουθίας */
        j=0; /* δείχνει σε θέσεις της δεύτερης ακολουθίας */
        k=0; /* δείχνει σε θέσεις της νέας ακολουθίας*/
        /* όσο δεν έχουμε φτάσει στο τέλος καμμίας από τις δύο ακολουθίες */
        while ((i<n1) && (j<n2))
        {
            /* εξετάζουμε τα στοιχεία που βρίσκονται στις θέσεις i και j των
            δύο ακολουθιών και βάζουμε το μικρότερο από αυτά (έστω ότι 
            βρίσκεται στην θέση i) στην νέα ακολουθία αυξάνοντας το μετρητή
            των θέσεώ της κατά 1 και το i κατά 1 */
            if (a[0][i] < a[1][j])
            {
                b[k]=a[0][i];
                i++;
            }
            else
            {
                b[k]=a[1][j];
                j++;
            }
            k++;
        }
        /* αν έχουν περισσέψει στοιχεία μιας από τις δύο ακολουθίες που δεν 
        έχουμε εξετάσει, τότε αυτά είναι σίγουρα μεγαλύτερα ή ίσα από το 
        τελευταίο στοιχείο που έχουμε βάλει στην νέα ακολουθία και συνεπώς
        απλά τα προσθέτουμε στο τέλος (παρατηρήστε ότι το πολύ ένα από τα 
        παρακάτω for-loops θα εκτελεστεί) */
        for (p=i;p<n1;p++)
        {
            b[k]=a[0][p];
            k++;
        }
        for (p=j;p<n2;p++)
        {
            b[k]=a[1][p];
            k++;
        }
        printf("H nea akolouthia einai\n");
        for (i=0;i<k;i++)
        printf("%d ",b[i]);
        printf("\n");
    }

    system("pause");
}
///TEST 1:
///INPUT: 1 2 3 4
///INPUT: 3 4 5 6 7 8 9 10

///OUTPUT: 1 2 3 3 4 4 5 6 7 8 9 10

///TEST 2:
///INPUT: 1 2 3 4 5 6 7 8 9 10 11
///Αν δέχεται και άλλο input δεν μας νοιάζει
///αρκει να μην τρέχει το πρόγραμμα και να βγάζει
///error (έχουμε δώσει πάνω από 10 ακέραιους)

///TEST 3:
///INPUT: 1 2 3 4
///INPUT: 1 2 3 4 5 6 7 8 9 10 11
///Ομοίως με το προηγούμενο

///TEST 4 , 5:
///Ομοίως με τα προηγούμενα απλά δίνω δεδομένα
///ταξινομημένα κατά φθίνουσα σειρά ή μη
///ταξινομημένα

